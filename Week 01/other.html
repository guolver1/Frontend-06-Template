<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>å©´å¹¼å„¿äº”å­æ£‹</title>
    <style>
        h2 {
            text-align: center;
            font-family: Menlo, "Microsoft Sans Serif";
        }
        #board {
            display: block;
            width: fit-content;
            margin: 100px auto;
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: #ffe09c;
            font-size: 40px;
            line-height: 40px;
            /* è¡Œå†…ç›’å¸ƒå±€é»˜è®¤ä¸ºåŸºçº¿å¯¹é½ */
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            background-color: #ffe09c;
            background-image: linear-gradient(white 1px, transparent 0), linear-gradient(90deg, white 1px, transparent 0);
            background-size: 200px 200px;
            background-position: 20px 20px;
        }

        .black {
            display: inline-block;
            border-radius: 50%;
            background: black;
            height: 25px;
            width: 25px;
            box-shadow: 0 0 5px #515151;
        }

        .white {
            display: inline-block;
            border-radius: 50%;
            height: 25px;
            width: 25px;
            background: white;
            box-shadow: 0 0 5px #373737;
        }
    </style>
</head>
<body>
<h2>å©´å¹¼å„¿äº”å­æ£‹- aiå¯¹æˆ˜</h2>
<div id="board"></div>
<script>

    let isFinished = false;
    const boardWidth = 10;
    const winNum = 5;
    // é»‘ç™½å­æ ·å¼
    const Black = `<span class="black">`;
    const White = `<span class="white">`;

    // ä¸ä¸€å®šé½å…¨ï¼Œäº”å­æ£‹æ£‹å‹
    const CHESSTYPE = {
        linkFive: ['11111'],
        liveFour: ['011110'],
        rushFour: ['-11110', '11101', '11011', '01111-', '10111',],
        liveThree: ['011100', '011010', '010110', '001110'],
        sleepThree: ['10011-', '-11100', '-11010', '-10110', '01101-', '01011-', '00111-', '-11001', '10101'],
        sleepTwo: ['-11000', '-01100', '00110-', '00011-'],
        liveTwo: ['011000', '010100', '001100', '010010', '001010', '000110'],
        liveOne: ['010000', '001000', '000100', '000010'],
        sleepOne: ['-10000', '-01000', '00010-', '00001-']
    }

    // åˆå§‹åŒ–æ£‹ç›˜
    let pattern = Array.from({length: boardWidth}).map(_ => Array.from({length: boardWidth}).fill(0));

    // é»‘å­ä¸º2
    let color = 2;
    // ç©å®¶æ–¹
    let user = color;
    // ç”µè„‘æ–¹
    let computer = 3 - user;
    // å…ˆæ‰‹æ–¹
    let first = user;

    // æœ€å¤§æœç´¢æ·±åº¦, æŒ‰é“ç†æ¥è¯´ï¼Œè°ƒæ•´ä»–èƒ½å¤Ÿä½¿aiæ›´å¼ºï¼Œä½†ä¼šå‡ºç°é•¿è€ƒã€‚ä¸è¿‡è¿™ä¸ªå¯èƒ½ç”±äºå±‚æ•°å¤ªä½æ˜¾å¾—æ¯”å•å±‚æœç´¢è¿˜è¦æ™ºéšœ.. éœ€è¦é…åˆABå‰ªæ
    const maxDepth = 1;


    // æå¤§æå°å€¼æœç´¢ç®—æ³•
    // 1. é¦–å…ˆå°†æ£‹ç›˜å‘ä¸‹æ¼”åŒ–å‡ æ­¥ï¼Œ å¾—åˆ°ä¸€é¢—åšå¼ˆæ ‘
    // 2. ä»å­èŠ‚ç‚¹å¼€å§‹ï¼Œè®¡ç®—å½“æ—¶çš„å¾—åˆ†ï¼Œå¦‚æœæ˜¯å¯¹æ–¹ä¸‹å°±è®¡ç®—å½“æ—¶æœ€å°å¾—åˆ†ï¼Œå¦‚æœæ˜¯æˆ‘ä»¬ä¸‹å°±è®¡ç®—æœ€å¤§å¾—åˆ†


    // è¿™ä¸ªå¾—åˆ†è¿˜æ˜¯éœ€è¦å¯¹äº”å­æ£‹æ¯”è¾ƒäº†è§£æ‰è¡Œï¼Œæ¯”å¦‚çœ ä¸‰å†²å››è¿™äº›æ£‹å‹çš„å¨èƒç¨‹åº¦
    let SCORE = {
        liveOne: 10,
        sleepOne: 1,
        liveTwo: 100,
        sleepTwo: 5,
        sleepThree: 90,
        liveThree: 1000,
        rushFour: 2000,
        liveFour: 8000,
        linkFive: 99999999,
        inaccessible: -99999999
    }

    let SCORE_FOR_ENEMY = {
        liveOne: -15,
        sleepOne: -2,
        liveTwo: -150,
        sleepTwo: -10,
        sleepThree: -100,
        liveThree: -1500,
        rushFour: -15000,
        liveFour: -20000,
        linkFive: -999999999,
        inaccessible: 999999999
    }

    function show(callback) {
        let board = document.getElementById('board');
        board.innerHTML = '';
        for (let i = 0; i < boardWidth; i++) {
            for (let j = 0; j < boardWidth; j++) {
                let cell = document.createElement('div');
                cell.classList.add('cell');
                cell.innerHTML = pattern[i][j] === 2 ? Black : pattern[i][j] === 1 ? White : "";
                cell.addEventListener('click', () => userMove(j, i));
                board.appendChild(cell);
            }
            board.appendChild(document.createElement('br'));
        }
        if (callback && !isFinished) {
            setTimeout(callback, 0);
        }
    }

    function userMove(x, y) {
        if (pattern[y][x] === 0 && !isFinished) {
            pattern[y][x] = color;
            let impactedPattern = getImpactPattern(pattern, [x, y], winNum);
            if (check(impactedPattern, color, winNum * 2 - 1)) {
                alert((color === 2 ? 'ä½ ' : "å©´å¹¼å„¿ç”µè„‘") + 'è·èƒœ!');
                isFinished = true;
            }
            color = 3 - color;
            show(computerMove);
        }
    }

    function getImpactPattern(originPattern, centerPosition, winNum) {
        const boardWidth = winNum * 2 - 1;
        let xOffset = centerPosition[1] - (winNum - 1);
        let yOffset = centerPosition[0] - (winNum - 1);
        let newPattern = Array.from({length: boardWidth}).map(_ => Array.from({length: boardWidth}).fill(0));
        for (let i = 0; i < boardWidth; i++) {
            for (let j = 0; j < boardWidth; j++) {
                newPattern[i][j] = originPattern[i + xOffset] ? originPattern[i + xOffset][j + yOffset] ? originPattern[i + xOffset][j + yOffset] : 0 : 0;
            }
        }
        return newPattern;
    }

    function computerMove() {
        if (!isFinished) {
            console.log('å¼€å§‹æ€è€ƒ...')
            let choice = bestChoice(pattern, color, 1);
            console.log('æ€è€ƒç»“æŸ')
            console.log(choice)
            if (choice.point) {
                pattern[choice.point[1]][choice.point[0]] = color;
            }
            let impactedPattern = getImpactPattern(pattern, choice.point, winNum);
            if (check(impactedPattern, color, winNum * 2 - 1)) {
                alert((color === 2 ? 'ä½ ' : "å©´å¹¼å„¿ç”µè„‘ğŸ¤¦â€â™€ï¸") + 'è·èƒœ!');
                isFinished = true;
            }
            color = 3 - color;
            show();
        }
    }


    // åªé’ˆå¯¹å½“å‰æ‰€è½çš„å­å½¢æˆä¸€ä¸ªå¯èƒ½çš„è¯„ä¼°èŒƒå›´ï¼Œåªåœ¨è¿™ä¸ªèŒƒå›´æ£€æŸ¥å°±å¯ä»¥äº†
    // å› ä¸ºå…¶ä»–èŒƒå›´æ˜¯ä¸ä¼šå—åˆ°è¿™ä¸ªå­è½å­çš„å½±å“çš„
    function check(pattern, color, boardWidth) {
        {
            for (let i = 0; i < boardWidth; i++) {
                let win = false;
                outer: for (let j = 0; j < boardWidth; j++) {
                    if (!pattern[i] || pattern[i][j] !== color) {
                        continue;
                    }
                    for (let k = 1; k < winNum; k++) {
                        if (!pattern[i] || pattern[i][j + k] !== color) {
                            j = j + k + 1;
                            break;
                        } else if (k === winNum - 1) {
                            win = true;
                            break outer;
                        }
                    }
                }
                if (win) {
                    return true;
                }
            }
        }
        {
            for (let i = 0; i < boardWidth; i++) {
                let win = false;
                outer: for (let j = 0; j < boardWidth; j++) {
                    if (!pattern[j] || pattern[j][i] !== color) {
                        continue;
                    }
                    for (let k = 1; k < winNum; k++) {
                        if (!pattern[j + k] || pattern[(j + k)][i] !== color) {
                            j = j + k + 1;
                            break;
                        } else if (k === winNum - 1) {
                            win = true;
                            break outer;
                        }
                    }
                }
                if (win) {
                    return true;
                }
            }
        }
        {
            let win = false;
            outer: for (let i = 0; i < boardWidth; i++) {
                if (!pattern[i] || pattern[i][i] !== color) {
                    continue;
                }
                for (let j = 0; j < winNum; j++) {
                    if (!pattern[i + j] || pattern[(i + j)][(i + j)] !== color) {
                        i = i + j + 1;
                        break;
                    } else if (j === winNum - 1) {
                        win = true;
                        break outer;
                    }
                }
            }
            if (win) {
                return true;
            }
        }
        {
            let win = false;
            outer: for (let i = 0; i < boardWidth; i++) {
                if (!pattern[i] || pattern[i][boardWidth - 1 - i] !== color) {
                    continue;
                }
                for (let j = 0; j < winNum; j++) {
                    if (!pattern[i + j] || pattern[(i + j)][boardWidth - 1 - i - j] !== color) {
                        i = i + j + 1;
                        break;
                    } else if (j === winNum - 1) {
                        win = true;
                        break outer;
                    }
                }
            }
            if (win) {
                return true;
            }
        }
        return false;
    }


    /**
     * è¯„ä¼°æ–¹æ³•: è®¡ç®—æ•´ä¸ªæ£‹å±€çš„æ£‹å‹å¾—åˆ†æ€»æ•°ï¼Œå±äºæˆ‘ä»¬çš„æ£‹å‹ä¸ºæ­£æ•°ï¼Œå±äºåˆ«äººçš„æ£‹å‹ä¸ºè´Ÿæ•°ï¼ŒåŠ å’Œè®¡ç®—
     * æˆ‘ä»¬å¹¶ä¸æ˜¯ä¸€å±‚ä¸€å±‚çš„ç®—åˆ†çš„ï¼Œå®é™…ä¸Šåªæœ‰æœ€åä¸€å±‚æ‰æœ‰å…·ä½“çš„è¯„ä¼°æ ‡å‡†ï¼Œ
     * å®é™…ä¸Šï¼Œæˆ‘ä»¬ç©·ä¸¾æ‰€æœ‰å¯èƒ½, ç›´æ¥å°†æ£‹å±€æ¼”åŒ–ä¸€å®šæ­¥æ•°
     * æ¯”å¦‚æ¯ä¸€æ­¥æœ‰2ç§å¯èƒ½ï¼Œæˆ‘ä»¬æ¼”åŒ–4æ­¥å°±æ˜¯ 2^4 = 16 ç§æ£‹ç›˜ï¼Œæ¯ç§æ£‹ç›˜è¿˜å¯¹åº”äº†å”¯ä¸€çš„è½å­é¡ºåº
     * å¯¹è¿™16æ£‹ç›˜æŒ‰ç…§è¯„ä¼°å‡½æ•°è®¡ç®—åˆ†æ•°
     * å¦‚æœæˆ‘ä»¬æ˜¯å…ˆæ‰‹ï¼Œåˆ™ç¬¬å››æ­¥æ˜¯å¯¹æ‰‹ä¸‹ï¼Œåˆ™æˆ‘ä»¬è®¡ç®—å‡ºæœ€ä½åˆ†ï¼Œå°±æ˜¯å‡è®¾å¯¹æ‰‹ä¹Ÿä¼šç©·ä¸¾ï¼Œè®¡ç®—åˆ°è¿™ä¸€æ­¥
     * å¯¹æ‰‹æ ¹æ®å½“å‰æ£‹ç›˜æƒ…å†µï¼Œå¾—å‡ºç¬¬ä¸‰æ­¥çš„8ç§æ£‹å±€ä¸‹å®ƒå„è‡ªä¼šé€‰æ‹©å“ªä¸€æ­¥ï¼Œè¿™ä¹Ÿå°±æ„æˆäº†ç¬¬ä¸‰æ­¥çš„å¾—åˆ†
     * ç¬¬ä¸‰æ­¥ç”±æˆ‘ä»¬èµ°ï¼Œ8ç§æ£‹å±€ å®é™…ä¸Šç”±ç¬¬äºŒæ­¥çš„4ç§æ£‹å±€æ¼”åŒ–è€Œæ¥ï¼Œæˆ‘ä»¬ä¼šé€‰æ‹©è¿™4ç§æ£‹å±€ä¸­å„è‡ªèµ°å“ªä¸€æ­¥ï¼Œä¼šè·å¾—4ä¸ªæ£‹å±€ä¸‹çš„å„è‡ªçš„æœ€é«˜åˆ†
     * è¿™ä¹Ÿå°±æ„æˆäº†ç¬¬äºŒæ­¥4ç§æ£‹å±€çš„å¾—åˆ†, ä¾æ¬¡å‘ä¸Šæ¨ï¼Œç§°ä¸ºæå¤§æå°å€¼ç®—æ³•ã€‚
     */


    /**
     * ç”±äºæ˜¯äººæœºå¯¹æˆ˜ï¼ŒbestChoice å½“ç„¶åªæœ‰ç”µè„‘æ‰ä¼šè°ƒç”¨ï¼Œå› æ­¤minmaxä¸€èˆ¬æœç´¢ç»ˆæ­¢äºå¶æ•°å±‚
     * @param pattern å½“å‰æ£‹ç›˜
     * @param color   å½“å‰é¢œè‰²
     * @param depth   å½“å‰æ·±åº¦
     */
    function bestChoice(pattern, color, depth) {
        // åˆ¤æ–­å½“å‰æ˜¯ç”¨æˆ·è¿˜æ˜¯ç”µè„‘
        let isUser = color === user;
        // åŸºå‡†æƒ…å†µï¼Œåˆ°è¾¾æœ€å¤§æœç´¢æ·±åº¦ï¼Œå¼€å§‹è®¡ç®—å®é™…æ£‹ç›˜å¾—åˆ†
        // å¯¹äºå¯¹æ–¹æ¥è¯´ï¼Œæœ€åçš„æƒ…å†µå°±æ˜¯æˆ‘ä»¬èµ¢äº†, å¯¹æˆ‘ä»¬æ¥è¯´åˆ™æ˜¯æˆ‘ä»¬è¾“
        let best = {
            point: null,
            score: isUser ? SCORE.linkFive : SCORE.inaccessible
        }
        let scores = [];
        // æœ€åä¸€å±‚ï¼Œè®¡ç®—å®é™…æ¯ä¸ªæ£‹ç›˜çš„å¾—åˆ†
        for (let i = 0; i < boardWidth; i++) {
            for (let j = 0; j < boardWidth; j++) {
                if (pattern[i][j] !== 0) {
                    continue;
                }
                let temp = naiveClone(pattern);
                temp[i][j] = color;
                // æœ€åä¸€å±‚æ°¸è¿œéƒ½æ˜¯è®¡ç®—ç”µè„‘çš„æ£‹å±€å¾—åˆ†å°±å¥½äº†ï¼Œåªéœ€è¦æ ¹æ®å½“å‰åˆ¤æ–­çš„æ˜¯ç”¨æˆ·è¿˜æ˜¯ç”µè„‘ï¼Œå–minæˆ–maxå³å¯
                if (depth === maxDepth) {
                    let score = evaluate(temp, computer);
                    let score_enemy = evaluateForEnemy(temp, user);
                    scores.push({
                        point: [j, i],
                        score: score + score_enemy
                    });
                } else {
                    // å…¶ä»–æƒ…å†µï¼Œé€’å½’çš„å»è·å¾—å­åšå¼ˆæ ‘ä¼ é€’ä¸Šæ¥çš„å€¼
                    scores.push({
                        point: [j, i],
                        score: bestChoice(temp, 3 - color, depth + 1).score
                    });
                }
            }
        }
        if (isUser) {
            scores.forEach(score => {
                if (score.score < best.score) {
                    best = score;
                }
            });
        } else {
            scores.forEach(score => {
                if (score.score > best.score) {
                    best = score;
                }
            });
        }
        return best;

    }


    /**
     * è®¡ç®—å±€åŠ¿
     * è¿™å—å›¾çœäº‹ï¼Œç›´æ¥å†™äº†ä¸¤ä¸ªå‡ ä¹ä¸€æ ·çš„å‡½æ•°ï¼Œé—®é¢˜ä¸å¤§
     * è¿™æ—¶çš„å±€åŠ¿å·²ç»æ˜¯æˆ‘æ–¹è½å­åçš„æƒ…å†µ
     * 1, æ£€æŸ¥æˆ‘æ–¹æ£‹å‹ï¼Œç»“æœä¸ºæ­£æ•°
     * 2. æ£€æŸ¥å¯¹æ–¹æ£‹å‹ï¼Œç»“æœä¸ºè´Ÿæ•°ï¼Œä¸”åŒæ£‹å‹å¯¹æ–¹çš„è´Ÿæ•°ç»å¯¹å€¼æ›´å¤§ï¼Œä½†ä¸å¤§è¿‡æˆ‘æ–¹æ›´ä¼˜æ£‹å‹
     * æ¯”å¦‚ æˆ‘æ–¹æ´»å›› å¤§äº å¯¹æ–¹æ´»ä¸‰ å¤§äº æˆ‘æ–¹æ´»ä¸‰
     * @param pattern
     * @param color ä½œä¸ºæ­£æ•°æ–¹çš„é¢œè‰²
     * @return {boolean|number}
     */
    function evaluate(pattern, color) {
        let chessTypeNum = {
            liveTwo: 0,
            liveOne: 0,
            sleepOne: 0,
            sleepTwo: 0,
            sleepThree: 0,
            liveThree: 0,
            rushFour: 0,
            liveFour: 0,
            linkFive: 0,
        };
        // æ¨ªç€æ£€æŸ¥
        {
            for (let i = 0; i < boardWidth; i++) {
                let string = '-';
                for (let j = 0; j < boardWidth; j++) {
                    if (pattern[i][j] === 0) {
                        string = string + '0';
                    } else if (pattern[i][j] === color) {
                        string = string + '1';
                    } else {
                        string = string + '-';
                    }
                }
                string += '-';
                for (const chess_type in CHESSTYPE) {
                    for (const type of CHESSTYPE[chess_type]) {
                        let result = string.match(type);
                        if (result && result.length) {
                            chessTypeNum[chess_type] += result.length;
                            if (chess_type === 'linkFive') {
                                return SCORE["linkFive"];
                            }
                        }

                    }
                }
            }
        }
        // ç«–ç€æ£€æŸ¥
        {
            for (let i = 0; i < boardWidth; i++) {
                let string = '-';
                for (let j = 0; j < boardWidth; j++) {
                    if (pattern[j][i] === 0) {
                        string = string + '0';
                    } else if (pattern[j][i] === color) {
                        string = string + '1';
                    } else {
                        string = string + '-';
                    }
                }
                string += '-';
                for (const chess_type in CHESSTYPE) {
                    for (const type of CHESSTYPE[chess_type]) {
                        let result = string.match(type);
                        if (result && result.length) {
                            chessTypeNum[chess_type] += result.length;
                            if (chess_type === 'linkFive') {
                                return SCORE['linkFive'];
                            }
                        }

                    }
                }
            }
        }
        // æ–œç€æ£€æŸ¥
        {
            // æ­£æ–œçº¿
            for (let k = -boardWidth + 1; k < boardWidth; k++) {
                for (let i = 0; i < boardWidth; i++) {
                    let string = '-';
                    for (let j = 0; j < boardWidth; j++) {
                        if (!pattern[i + j + k] || pattern[i + j + k][i + j] === 3 - color) {
                            string = string + '-';
                        } else if (pattern[i + j + k][i + j] === 0) {
                            string = string + '0';
                        } else if (pattern[i + j + k][i + j] === color) {
                            string = string + '1';
                        }
                    }
                    string += '-';
                    for (const chess_type in CHESSTYPE) {
                        for (const type of CHESSTYPE[chess_type]) {
                            let result = string.match(type);
                            if (result && result.length) {
                                chessTypeNum[chess_type] += result.length;
                                if (chess_type === 'linkFive') {
                                    return SCORE['linkFive'];

                                }
                            }

                        }
                    }
                }
            }

            // åæ–œçº¿
            for (let k = -boardWidth + 1; k < boardWidth; k++) {
                for (let i = 0; i < boardWidth; i++) {
                    let string = '-';
                    for (let j = 0; j < boardWidth; j++) {
                        if (!pattern[i + j + k] || pattern[i + j + k][boardWidth - 1 - i - j] === 3 - color) {
                            string = string + '-';
                        } else if (pattern[i + j + k][boardWidth - 1 - i - j] === 0) {
                            string = string + '0';
                        } else if (pattern[i + j + k][boardWidth - 1 - i - j] === color) {
                            string = string + '1';
                        }
                    }
                    string += '-';
                    for (const chess_type in CHESSTYPE) {
                        for (const type of CHESSTYPE[chess_type]) {
                            let result = string.match(type);
                            if (result && result.length) {
                                chessTypeNum[chess_type] += result.length;
                                if (chess_type === 'linkFive') {
                                    return SCORE['linkFive'];
                                }
                            }
                        }
                    }
                }
            }
        }

        let result = 0;
        Object.keys(chessTypeNum).forEach(chessType => {
            result += (SCORE[chessType] * chessTypeNum[chessType]);
        });
        return result;
    }

    function evaluateForEnemy(pattern, color) {
        let chessTypeNum = {
            liveTwo: 0,
            liveOne: 0,
            sleepOne: 0,
            sleepTwo: 0,
            sleepThree: 0,
            liveThree: 0,
            rushFour: 0,
            liveFour: 0,
            linkFive: 0,
        };
        // æ¨ªç€æ£€æŸ¥
        {
            for (let i = 0; i < boardWidth; i++) {
                let string = '-';
                for (let j = 0; j < boardWidth; j++) {
                    if (pattern[i][j] === 0) {
                        string = string + '0';
                    } else if (pattern[i][j] === color) {
                        string = string + '1';
                    } else {
                        string = string + '-';
                    }
                }
                string += '-';
                for (const chess_type in CHESSTYPE) {
                    for (const type of CHESSTYPE[chess_type]) {
                        let result = string.match(type);
                        if (result && result.length) {
                            chessTypeNum[chess_type] += result.length;
                            if (chess_type === 'linkFive') {
                                return SCORE_FOR_ENEMY["linkFive"];
                            }
                        }

                    }
                }
            }
        }
        // ç«–ç€æ£€æŸ¥
        {
            for (let i = 0; i < boardWidth; i++) {
                let string = '-';
                for (let j = 0; j < boardWidth; j++) {
                    if (pattern[j][i] === 0) {
                        string = string + '0';
                    } else if (pattern[j][i] === color) {
                        string = string + '1';
                    } else {
                        string = string + '-';
                    }
                }
                string += '-';
                for (const chess_type in CHESSTYPE) {
                    for (const type of CHESSTYPE[chess_type]) {
                        let result = string.match(type);
                        if (result && result.length) {
                            chessTypeNum[chess_type] += result.length;
                            if (chess_type === 'linkFive') {
                                return SCORE_FOR_ENEMY['linkFive'];
                            }
                        }

                    }
                }
            }
        }
        // æ–œç€æ£€æŸ¥
        {
            // æ­£æ–œçº¿
            for (let k = -boardWidth + 1; k < boardWidth; k++) {
                for (let i = 0; i < boardWidth; i++) {
                    let string = '-';
                    for (let j = 0; j < boardWidth; j++) {
                        if (!pattern[i + j + k] || pattern[i + j + k][i + j] === 3 - color) {
                            string = string + '-';
                        } else if (pattern[i + j + k][i + j] === 0) {
                            string = string + '0';
                        } else if (pattern[i + j + k][i + j] === color) {
                            string = string + '1';
                        }
                    }
                    string += '-';
                    for (const chess_type in CHESSTYPE) {
                        for (const type of CHESSTYPE[chess_type]) {
                            let result = string.match(type);
                            if (result && result.length) {
                                chessTypeNum[chess_type] += result.length;
                                if (chess_type === 'linkFive') {
                                    return SCORE_FOR_ENEMY['linkFive'];

                                }
                            }

                        }
                    }
                }
            }

            // åæ–œçº¿
            for (let k = -boardWidth + 1; k < boardWidth; k++) {
                for (let i = 0; i < boardWidth; i++) {
                    let string = '-';
                    for (let j = 0; j < boardWidth; j++) {
                        if (!pattern[i + j + k] || pattern[i + j + k][boardWidth - 1 - i - j] === 3 - color) {
                            string = string + '-';
                        } else if (pattern[i + j + k][boardWidth - 1 - i - j] === 0) {
                            string = string + '0';
                        } else if (pattern[i + j + k][boardWidth - 1 - i - j] === color) {
                            string = string + '1';
                        }
                    }
                    string += '-';
                    for (const chess_type in CHESSTYPE) {
                        for (const type of CHESSTYPE[chess_type]) {
                            let result = string.match(type);
                            if (result && result.length) {
                                chessTypeNum[chess_type] += result.length;
                                if (chess_type === 'linkFive') {
                                    return SCORE_FOR_ENEMY['linkFive'];
                                }
                            }
                        }
                    }
                }
            }
        }

        let result = 0;
        Object.keys(chessTypeNum).forEach(chessType => {
            result += (SCORE_FOR_ENEMY[chessType] * chessTypeNum[chessType]);
        });
        return result;
    }


    function naiveClone(pattern) {
        return JSON.parse(JSON.stringify(pattern));
    }

    show();

</script>
</body>
</html>