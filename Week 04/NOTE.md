学习笔记
##字典树
- 用Object或者Map来存储字典树
- 随机生成一个字母的方法：

`String.fromCharCode(Math.random()*26+"a".charCodeAt(0));`

fromCharCode：Unicode->字符
charCodeAt（n）: 字符-> Unicode，返回第n个字符的Unicode

##KMP字符串模式匹配算法
- 待查的串和pattern串
- 关注字符串的自重复行为，分别从前面开始截短
- 理解： 使用PMT,理解代码中的j = table[j];

- table就是Next数组，Next是PMT后移一位
- 要在主字符串"ababababca"中查找模式字符串"abababca"。如果在 j 处字符不匹配，那么由于前边所说的模式字符串 PMT 的性质，主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配，也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了，模式字符串从 0 到 j−1 ，在这个例子中就是”ababab”，其前缀集合与后缀集合的交集的最长元素为”abab”， 长度为4。所以就可以断言，主字符串中i指针之前的 4 位一定与模式字符串的第0位至第 4 位是相同的，即长度为 4 的后缀与前缀相同。这样一来，我们就可以将这些字符段的比较省略掉。具体的做法是，保持i指针不动，然后将j指针指向模式字符串的PMT[j −1]位即可

